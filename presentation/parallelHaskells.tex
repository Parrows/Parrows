\section{Parallel Arrows}
\subsection{Introduction to Parallelism}
\begin{frame}[fragile]
In general, Parallelism can be looked at as:
\begin{lstlisting}[frame=htrbl]
parEvalN :: [a -> b] -> [a] -> [b]
\end{lstlisting}

Roadmap:
\begin{itemize}
\item Implement using existing Haskells
\begin{itemize}
\item Multicore
\item ParMonad
\item Eden
\end{itemize}
\item Generalize to Arrows
\item Adapt Implementations
\item Profit
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Multicore Haskell}
\begin{lstlisting}[frame=htrbl]
parEvalN :: (NFData b) => [a -> b] -> [a] -> [b]
parEvalN fs as = zipWith ($) fs as `using` parList rdeepseq
\end{lstlisting}
with
\\~\\
\code{zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]}
\code{(\$) :: (a -> b) -> a -> b}\\
\code{using :: a -> Strategy a -> a}\\
\code{parList :: Strategy a -> Strategy [a]}\\
\code{rdeepseq :: NFData a =>Strategy a}
\end{frame}

\begin{frame}[fragile]{ParMonad}
\begin{lstlisting}[frame=htrbl]
parEvalN :: (NFData b) => [a -> b] -> [a] -> [b]
parEvalN fs as = runPar $ 
	(sequence $ map (spawnP) $ zipWith ($) fs as) >>= mapM get
\end{lstlisting}
with
\\~\\
\code{runPar :: Par a -> a}\\
\code{(\$) :: (a -> b) -> a -> b}\\
\code{sequence :: (Monad m) => [m a] -> m [a]}\\
\code{map :: (a -> b) -> [a] -> [b]}\\
\code{spawnP :: NFData a => a -> Par (IVar a)}\\
\code{zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]}\\
\code{(>>=) :: m a -> (a -> m b) -> m b}\\
\code{mapM :: Monad m => (a -> m b) -> [a] -> m [b]}\\
\code{get :: IVar a -> Par a}
\end{frame}

\begin{frame}[fragile]{Eden}
\begin{lstlisting}[frame=htrbl]
parEvalN :: (Trans a, Trans b) => [a -> b] -> [a] -> [b]
parEvalN fs as = spawnF fs as
\end{lstlisting}
with
\\~\\
\code{spawnF :: (Trans a, Trans b) => [a -> b] -> [a] -> [b]}
\end{frame}