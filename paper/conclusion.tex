\section{Conclusion}
As we have seen in this paper, arrows are a useful tool for composing parallel programs. By basing our parallel Haskell on them, we do not have to introduce new monadic types that wrap the computation and instead can use them just like they were regular sequential pure code. Performancewise, parallel arrows are on par with existing parallel Haskells, as they do not introduce any notable overhead.

\fixme{ArrowApply (or equivalent) are needed because we basically want to be able to produce intermediary results, this is by definition of the parallel evaluation combinators}