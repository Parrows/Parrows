\section{Conclusion}
As we have seen in this paper, arrows are a useful tool for composing parallel programs. We have already seen that they have some benefits over existing parallel Haskells as they are, by nature, more extensible. Performancewise, parallel arrows are on par with existing parallel Haskells, as they do not introduce any notable overhead. While we have seen that the parallel arrows can express computation on clusters, it is noteworthy that in its current state, the parallel arrow API doesn't have as much control over data-flow as for example Eden. In its current state this will end up in the root node being a possible bottleneck on clusters when parallel arrows are combined with \code{>>>}. This can probably be remedied by introducing some sort of a Java-like Future construct that can be passed between nodes so that nodes can communicate without going through the root node. This will have to be implemented in a follow up paper, though.