%\section{Motivation}
%Arrows were introduced in John Hughes paper as a general interface for computation and therefore as an alternative to Monads for API design \citHughes. In the paper Hughes describes how arrows are a generalization of Monads and how they are not as restrictive. In this paper we will use this concept to express parallelism.

\section{Introduction}
\label{sec:introduction}
% \olcomment{todo, reuse 5.5, and more}
%
% \mbcomment{
% Haskell is Spielwiese für Parallelität; verschiedene Ansätze (Par, Multicore, Eden); Orthogonale Ansätze; Verwenden höchstens eine Monade - manchmal auch nur intern; Wir wollen Parallelität mit Arrows abbilden, was noch niemand gemacht hat;
% Statt einer eigenen Implementierung definieren wir ein "shallow embedded DSL" (ACHTUNG, ist das der richtige Name? effektiv API);
% Umsetzung mit verschiedenen parallelen Haskells; We tame the zoo of parallel Haskells und vergewissern uns dass es nicht viel Overhead bringt
% }
%
% blablabla arrows, parallel, haskell.
%
% \olcomment{An attempt ---->}
%%%%%

One particular reason for this is the ease of introducing new sophisticated language
concepts. Parallel functional languages have a long history of being used for experimenting with novel parallel programming paradigms including the expression of parallelism. Haskell, which we focus on in this paper, has  several mature implementations. We regard here in-depth
the Multicore Haskell (a SMP implementation of GpH language), the
|Par| Monad, and Eden, a distributed memory parallel Haskell. These
languages represent orthogonal approaches. Some use a monad, even if
only for the internal representation. Some introduce additional
language constructs. 
%In this paper we introduce a notion of parallel
%computations using Arrows.
A key novelty here is to use Arrows to represent parallel computations. They seem a natural fit as they are a generalization of the function |->| and serve as general interface to computations.

%Our Arrows-based interface is a high-level one.
We provide an Arrows-based typeclass and implementations for three parallel Haskells.
Instead of 
introducing a new low-level parallel backend in order to implement our
Arrows-based interface, we define a shallow-embedded DSL for Arrows. This DSL
is defined as a common interface and varying implementations in
existing parallel Haskells: Multicore Haskell, |Par| Monad, and
Eden. Thus, we not only define a parallel programming interface in a
novel manner - we tame the zoo of parallel Haskells. We provide a
common \ptcomment{quantify, e.g. less than 10 \%}, very low-penalty programming interface that allows to switch
the parallel Haskell backends at will. Further backends based on HdpH or a Frege implementation (on the Java Virtual Machine) are viable, too.

\paragraph{Contributions}
%
%\olcomment{HIT HERE REALLY STRONG}
%
%\subsection{Impact of parallel Arrows}
%\olcomment{move this to Contributions in the front or something}
\mbcomment{different, how?}
%We wrap parallel Haskells inside of our |ArrowParallel| typeclass, but
% why do we aim to abstract parallelism this way and what does this
% approach do better than the other parallel Haskells?
% is such a parallelism abstraction of benefit and to what extent does
% it improve existing approaches?
\begin{itemize}
	\item \textbf{Arrow DSL benefits}:
    To implement parallelism, we do not introduce any new types, but only rely on a typeclass that hosts |parEvalN :: [arr a b] -> arr [a] [b]|, which converts a list of arrows into a new parallel arrow. Therefore, we do not lose any benefits of using arrows as parallelism is just encapsulated in yet another Arrow combinator. The resulting Arrow can be used in the same way a potential serial version could be used. This is a big advantage of this approach, especially compared to Monad solutions like the |Par| Monad which require specialized Monad types. We can just \enquote{plug} in parallel parts into sequential Arrow-based programs without having to change anything.
	\item \textbf{Abstraction}:
	With the |ArrowParallel| typeclass, we abstract all parallel implementation logic away from the business logic. This means it is possible to write our code against the interface of a common typeclass without being bound to any parallel Haskell. So as an example, during development, we can run the program in a simple GHC-compiled variant and afterwards deploy it on a cluster by converting it into an Eden version, by just replacing the current |ArrowParallel| instance.
\end{itemize}


\paragraph{Structure}
The remaining text is structures as follows. Section~\ref{sec:background} briefly introduces known parallel Haskell flavours (Sec.~\ref{sec:parEvalNIntro}) and gives an overview of Arrows to the reader (Sec.~\ref{sec:arrows}). Section~\ref{sec:related-work} discusses related work. Section~\ref{sec:parallel-arrows} defines Parallel Arrows and presents a basic interface. Section~\ref{futures} defines Futures for Parallel Arrows, this concept enables better communication. Section~\ref{sec:map-skeletons} presents some basic algorithmic skeletons  in our newly defined dialect: parallel |map| with and without load balancing. More advanced skeletons are showcased in Section~\ref{sec:topology-skeletons} (|pipe|, |ring|, |torus|). Section~\ref{sec:benchmarks} shows the benchmark results. Section~\ref{sec:conclusion} discusses future work and concludes.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
