\section{Related Work}
\label{sec:related-work}

\ptcomment{The non-strict semantics of Haskell, and the fact that reduction encapsulates computations as closures, makes it relatively easy to define alternate parallelisations. A range of approaches have been explored, including data parallelism (Chakravarty et al., 2007; Keller et al.,
2010), GPU-based approaches (Mainland & Morrisett, 2010; Svensson, 2011), software
transactional memory (Harris et al., 2005; Perfumo et al., 2008). The Haskellâ€“GPU bridge
Accelerate (Chakravarty et al., 2011; Clifton-Everest et al., 2014; McDonell et al., 2015)
deserves a special mention. <<Why does it deserve special mention?>>  Accelerate is completely orthogonal to our approach. A good survey of parallel Haskells can be found in ~\cite{Marlow2013}. 


Our PArrow implementation uses three task parallel languages as backends: the
GpH (Trinder et al., 1996, 1998) parallel Haskell dialect and its multicore version (Marlow
et al., 2009), the Par Monad (Marlow et al., 2011; Foltzer et al., 2012), and Eden (Loogen
et al., 2005; Loogen, 2012). These languages are under active development, for example a combined shared and distributed memory implementation of GpH is available (Aljabri et al., 2014,
2015). Research on Eden includes a low-level  implementation (Berthold, 2008; Berthold et al., 2016), work on skeleton
composition (Dieterle et al., 2016), communication (Dieterle et al., 2010a), and generation
of process networks (Horstmeyer & Loogen, 2013). The definitions of new Eden skeletons is a specific focus (Hammond et al., 2003; Berthold
& Loogen, 2006; Berthold et al., 2009b,c; Dieterle et al., 2010b; de la Encina et al., 2011;
Dieterle et al., 2013; Janjic et al., 2013).

Other task parallel Haskells related to Eden, GpH, and the Par Monad include the following.  
HdpH (Maier et al., 2014; Stewart et al., 2016) is an extension of Par Monad to
heterogeneous clusters. LVish (Kuper et al., 2014) is a communication-centred extension
of Par Monad.}


\paragraph{Parallel Haskells.}
The non-strict semantics of Haskell, and the fact that reduction encapsulates computations as closures, makes it relatively easy to define alternate parallelisations. A range of approaches have been explored, including data parallelism \cite{Chakravarty2007,Keller:2010:RSP:1932681.1863582}, GPU-based approaches \cite{Mainland:2010:NEC:2088456.1863533,obsidian-phd}, software transactional memory \cite{Harris:2005:CMT:1065944.1065952,Perfumo:2008:LST:1366230.1366241}.
The Haskell--GPU bridge Accelerate
\cite{Chakravarty:2011:AHA:1926354.1926358,CMCK14,McDonell:2015:TRC:2887747.2804313}
is completely orthogonal to our approach.
A~good survey of parallel Haskells can be found in~\citet{marlow2013parallel}.

Our PArrow implementation uses three task parallel languages as backends: the GpH \cite{Trinder1996,Trinder1998a} parallel Haskell dialect and its multicore version \cite{Marlow2009}, the |Par| Monad \cite{par-monad,Foltzer:2012:MPC:2398856.2364562}, and Eden \cite{eden,Loogen2012}. These languages are under active development, for example a combined shared and distributed memory implementation of GpH is available \cite{Aljabri:2013:DIG:2620678.2620682,Aljabri2015}.
Research on Eden includes low-level  implementation
\cite{JostThesis,berthold_loidl_hammond_2016}, skeleton composition
\cite{dieterle_horstmeyer_loogen_berthold_2016}, communication \cite{Dieterle2010}, and generation of process networks \cite{Horstmeyer2013}. The definitions of new Eden skeletons is a specific focus \cite{doi:10.1142/S0129626403001380,Eden:PARCO05,Berthold2009-mr,Berthold2009-fft,dieterle2010skeleton,delaEncina2011,Dieterle2013,janjic2013space}.

Other task parallel Haskells related to Eden, GpH, and the |Par| Monad include the following.  
HdpH \cite{Maier:2014:HDS:2775050.2633363,stewart_maier_trinder_2016} is an extension of |Par| Monad to
heterogeneous clusters. LVish \cite{Kuper:2014:TPE:2666356.2594312} is a communication-centred extension
of |Par| Monad.

\olcomment{OLD:
\paragraph{Parallel Haskells.}
Of course, the three parallel Haskell flavours we use as backends: the GpH \cite{Trinder1996,Trinder1998a} parallel Haskell dialect and its multicore version \cite{Marlow2009}, the |Par| Monad \cite{par-monad,Foltzer:2012:MPC:2398856.2364562}, and Eden \cite{eden,Loogen2012} are related to this work. We use these languages as backends: our DSL can switch from one to another at user's command.

HdpH \cite{Maier:2014:HDS:2775050.2633363,stewart_maier_trinder_2016} is an extension of |Par| Monad to heterogeneous clusters. LVish \cite{Kuper:2014:TPE:2666356.2594312} is a communication-centred extension of |Par| Monad.
%
Further parallel Haskell approaches include pH \cite{ph-book}, research work done on distributed variants of GpH \cite{Trinder1996,Aljabri:2013:DIG:2620678.2620682,Aljabri2015}, and low-level Eden implementation \cite{JostThesis,berthold_loidl_hammond_2016}. Skeleton composition \cite{dieterle_horstmeyer_loogen_berthold_2016}, communication \cite{Dieterle2010}, and generation of process networks \cite{Horstmeyer2013} are recent in-focus research topics in Eden. This also includes the definitions of new skeletons \cite{doi:10.1142/S0129626403001380,Eden:PARCO05,Berthold2009-mr,Berthold2009-fft,dieterle2010skeleton,delaEncina2011,Dieterle2013,janjic2013space}.

Alternative approaches include data parallelism \cite{Chakravarty2007,Keller:2010:RSP:1932681.1863582}, GPU-based approaches \cite{Mainland:2010:NEC:2088456.1863533,obsidian-phd}, software transactional memory \cite{Harris:2005:CMT:1065944.1065952,Perfumo:2008:LST:1366230.1366241}.
%
The Haskell--GPU bridge Accelerate
\cite{Chakravarty:2011:AHA:1926354.1926358,CMCK14,McDonell:2015:TRC:2887747.2804313}
deserves a special mention. Accelerate is completely orthogonal to our
approach. \citeauthor{marlow2013parallel} authored a recent book in
\citeyear{marlow2013parallel} on parallel Haskells.
}

\paragraph{Algorithmic skeletons.}
Algorithmic skeletons were introduced by \citet{Cole1989}.
Early publications on this topic include \cite{DANELUTTO1992205,darlington1993parallel,botorog1996efficient,Lengauer1997,Gorlatch1998}. \citet{SkeletonBook} consolidated early reports on high-level programming approaches.
Typical types of algorithmic skeletons include |map|-, |fold|-, and |scan|-based parallel programming patterns, special applications such as divide-and-conquer or topological skeletons.

The |farm| skeleton \citep{Hey1990185,Eden:PPDP01,Kuchen05} is a statically task-balanced parallel |map|. When tasks' durations cannot be foreseen, a dynamic load balancing (|workpool|) brings a lot of improvement \citep{Rudolph:1991:SLB:113379.113401,doi:10.1142/S0129626403001380,Hippold2006,PADL08HMWS,Marlow2009}. For special tasks |workpool| skeletons can be extended with dynamic task creation \cite{WPEuropar06,Dinan:2009:SWS:1654059.1654113,brown2010ever}. Efficient load-balancing schemes for |workpool|s are subject of research \cite{Blumofe:1999:SMC:324133.324234,Acar:2000:DLW:341800.341801,vanNieuwpoort:2001:ELB:568014.379563,Chase:2005:DCW:1073970.1073974,4625841,Michael:2009:IWS:1594835.1504186}.
%
The |fold| (or |reduce|) skeleton was implemented in various skeleton libraries \cite{Kuchen2002,5361825,BUONO20102095,Dastgeer:2011:ASM:1984693.1984697}, as also its inverse, |scan| \cite{Bischof2002,harris2007parallel}.
%
Google |map|--|reduce| \cite{Dean:2008:MSD:1327452.1327492,Dean:2010:MFD:1629175.1629198} is more special than just a composition of the two skeletons \cite{LAMMEL20081,Berthold2009-mr}.

The effort is ongoing, including topological skeletons \cite{Eden:PARCO05}, special-purpose skeletons for computer algebra \cite{Berthold2009-fft,lobachev-phd,Lobachev2012,janjic2013space}, iteration skeletons \cite{Dieterle2013}. The idea of \citet{scscp} is to use a parallel Haskell to orchestrate further software systems to run in parallel. \citet{dieterle_horstmeyer_loogen_berthold_2016} compare the composition of skeletons to stable process networks.

\paragraph{Arrows.}
Arrows were introduced by \citet{HughesArrows} as a less restrictive alternative to Monads, in essence they are a generalised function arrow~|->|. \citet{Hughes2005} presents a tutorial on Arrows. \citet{jacobs_heunen_hasuo_2009,LINDLEY201197,ATKEY201119} develop theoretical background of Arrows. \citet{Paterson:2001:NNA:507669.507664} introduced a new notation for Arrows. Arrows have applications in information flow research \cite{1648705,LI20101974,Russo:2008:LLI:1411286.1411289}, invertible programming \cite{Alimarine:2005:BAA:1088348.1088357}, and quantum computer simulation \cite{vizzotto_altenkirch_sabry_2006}. But probably most prominent application of Arrows is Arrow-based functional reactive programming, AFRP \cite{Nilsson:2002:FRP:581690.581695,Hudak2003,Czaplicki:2013:AFR:2499370.2462161}.
\citet{Liu:2009:CCA:1631687.1596559} formally define a more special kind of Arrows that capsule the computation more than regular Arrows do and thus enable optimisations. Their approach would allow parallel composition, as their special Arrows would not interfere with each other in concurrent execution. In contrast, we capture a whole parallel computation as a single entity: our main instantiation function |parEvalN| makes a single (parallel) Arrow out of list of Arrows. \citet{Huang2007} utilise Arrows for parallelism, but strikingly different from our approach. They use Arrows to orchestrate several tasks in robotics. We, however, propose a general interface for parallel programming, while remaining completely in Haskell.

\paragraph{Arrows in other languages.}
Although this work is centred on Haskell implementation of Arrows, it is applicable to any functional programming language where parallel evaluation and Arrows can be defined. Basic definitions of PArrows are possible in the Frege language\footnote{GitHub project page at \url{https://github.com/Frege/frege}} (which is basically Haskell on the JVM). However, they are beyond the scope of this work, as are similar experiments with the Eta language\footnote{Eta project page at \url{http://eta-lang.org}}, 
a new approach to Haskell on the JVM.

\citet{achten2004arrows,achten2007arrow} use an Arrow implementation in Clean for better handling of typical GUI tasks. \citet{Dagand:2009:ORD:1481861.1481870} used Arrows in OCaml in the implementation of a distributed system.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
