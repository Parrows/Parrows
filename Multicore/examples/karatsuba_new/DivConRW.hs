{-# OPTIONS -cpp #-}
{- Divide and conquer skeleton on top of replicated workers.
   The first parameter of divCon defines the depth at which
   the divide&conquer tree is generated by the main tasks,
   using function generateTasks. After generating enough tasks,
   the replicated workers skeleton is used to solve them with
   a good load balance. Finally, function combineTop combine
   the partial results obtained.
   The data type Tree is needed to pass information from 
   generateTasks to combineTop, so that the subresults can
   be combined in the proper way.   
   
                                              -- FR10 --
-}                                              
   

module DivConRW where
-- (divConRW,divConDM,divConRW2,divConDM_N,divConDM_N_NoRes) where
import Prelude hiding (seq)
import Control.Parallel (pseq)
import Control.Parallel.Strategies (parList,using,NFData)  
import Control.Parallel.Strategies as M (parMap)
import Control.Parallel.Strategies (rdeepseq,Strategy)

--import ParallelSplit.ParMonad
import Control.Arrow
import Parrows.Definition
import Parrows.Skeletons.Map as P
import Parrows.Multicore

-- import Eden
-- import RW 

-- workpools by MD
-- import EdenMWToken (mwNest')

-- edi workpool, sorting
-- import EdiWP

import Data.List
import System.IO.Unsafe
import Control.Monad
import Data.List.Split
import Data.Maybe
-- import Observe 

rnf :: NFData a => Strategy a
rnf = rdeepseq -- incorrect, rnf is old signature, but works this way with `using`


seq = pseq 

divConSeq :: (a->Bool) -> (a->b) -> (a->[a]) -> (a->[b]->b) -> a -> b
divConSeq trivial solve split combine x 
 | trivial x = solve x
 | otherwise = combine x children
 where children = map (divConSeq trivial solve split combine) (split x)

parMapFOrig :: (NFData b) => (a -> b) -> [a] -> [b]
parMapFOrig = P.parMap ()

parMapFMulticore :: (NFData b) => (a -> b) -> [a] -> [b]
parMapFMulticore = M.parMap rdeepseq

farmChunkF :: (NFData b) => (a -> b) -> [a] -> [b]
farmChunkF fs as = P.farmChunk () 10 4 fs as

divConRW :: (NFData a, NFData b) => Int -> Int -> (a->Bool) -> (a->b) -> (a->[a]) -> (a->[b]->b) -> a -> b
divConRW depth _ trivial solve split combine x
 | trivial x = solve x
 | otherwise = children
 where children =
	if depth>0 then
	    -- parallel
	    combine x $ farmChunkF (divConRW (depth - 1) 0 trivial solve split combine) (split x)
	else
	    -- sequential weiter
	    combine x $ map (divConRW (depth-1) 0 trivial solve split combine) (split x)