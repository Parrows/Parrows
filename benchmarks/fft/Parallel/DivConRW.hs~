{-# OPTIONS -cpp #-}
{- Divide and conquer skeleton on top of replicated workers.
   The first parameter of divCon defines the depth at which
   the divide&conquer tree is generated by the main tasks,
   using function generateTasks. After generating enough tasks,
   the replicated workers skeleton is used to solve them with
   a good load balance. Finally, function combineTop combine
   the partial results obtained.
   The data type Tree is needed to pass information from 
   generateTasks to combineTop, so that the subresults can
   be combined in the proper way.   
   
                                              -- FR10 --
-}                                              
   

module DivConRW(divConRW,divConFarm) where
import Eden
-- import RW 

-- workpools by MD
-- import EdenMWToken

-- edi workpool, sorting
import EdiWP

import Data.List
import System.IO.Unsafe
import Control.Monad

mw :: (Trans a, Trans b) => 
      Int -> Int -> (a -> b) -> [a] -> [b]
mw = ediWPf

-- farm:
unshuffle :: Int -> [a] -> [[a]]
unshuffle n xs = [takeEach n (drop i xs) | i <- [0..n-1]]
takeEach :: Int -> [a] -> [a] 
takeEach n [] = []
takeEach n (x:xs) = x : takeEach n (drop (n-1) xs)
shuffle :: [[a]] -> [a]
shuffle = concat . transpose

farm :: (Trans a, Trans b) => Int -> (a -> b) -> [a] -> [b]
farm np f ts = let inputss = unshuffle np ts 
	       in shuffle (parMapAt (repeat 0) (map f) inputss)

parMapAt :: (Trans a, Trans b) => [Int] -> (a -> b) -> [a] -> [b]
parMapAt places f xs
    = unsafePerformIO (
         zipWithM (\pe x -> instantiateAt pe (process f) x)
                  places xs
        )

       
divConSeq :: (a->Bool) -> (a->b) -> (a->[a]) -> (a->[b]->b) -> a -> b
divConSeq trivial solve split combine x 
 | trivial x = solve x
 | otherwise = combine x children
 where children = map (divConSeq trivial solve split combine) (split x)



divConRW :: (Trans a,Trans b) => 
           Int -> (a->Bool) -> (a->b) -> (a->[a]) -> (a->[b]->b) -> a -> b
divConRW depth trivial solve split combine x = combineTop combine levels results
  where (tasks,levels) = generateTasks depth trivial split x
        results        = workpool (divConSeq trivial solve split combine) tasks
			 --------
	workpool f tasks = mw pes 10 f tasks

divConFarm :: (Trans a,Trans b) => 
           Int -> (a->Bool) -> (a->b) -> (a->[a]) -> (a->[b]->b) -> a -> b
divConFarm depth trivial solve split combine x = combineTop combine levels results
  where (tasks,levels) = generateTasks depth trivial split x
        results        = farm pes  (divConSeq trivial solve split combine) tasks
			 --------
pes :: Int
pes = max 1 (noPe-1)

data Tree a = Tree a [Tree a] | Leaf a

generateTasks :: Int -> (a->Bool) -> (a->[a]) -> a -> ([a],Tree a)
generateTasks 0 _ _ a = ([a],Leaf a)
generateTasks n trivial split a
 | trivial a = ([a],Leaf a)
 | otherwise = (concat ass,Tree a ts)
 where assts = map (generateTasks (n-1) trivial split) (split a)
       (ass,ts) = unzip assts
                     
combineTop :: (a->[b]->b) -> (Tree a) -> [b] -> b
combineTop c t bs = fst (combineTop' c t bs)

#if 1
combineTop' :: (a->[b]->b) -> (Tree a) -> [b] -> (b,[b])
combineTop' _ (Leaf a) (b:bs) = (b,bs)
combineTop' combine (Tree a ts) bs = (combine a (reverse res),bs')
 where (bs',res) = foldl f (bs,[]) ts
       f (olds,news) t = (remaining,b:news) -- olds sin algo, news mas b
         where (b,remaining) = combineTop' combine t olds
#else
combineTop' :: (a->[b]->b) -> (Tree a) -> [b] -> (b,Int)
combineTop' _ (Leaf a) (b:bs) = (b,1)
combineTop' combine (Tree a ts) bs = (combine a res,length bs - length bs')
 where (bs',res) = foldl f (bs,[]) ts
       f (olds,news) t = (drop n olds,news++[b]) -- olds sin algo, news mas b
         where (b,n) = combineTop' combine t olds
#endif

